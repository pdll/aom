"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3566],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=o,f=m["".concat(c,".").concat(d)]||m[d]||u[d]||a;return n?r.createElement(f,i(i({ref:t},l),{},{components:n})):r.createElement(f,i({ref:t},l))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2169:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return l},default:function(){return m}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={title:"Extra schemas usage",sidebar_position:7},c=void 0,p={unversionedId:"api/openapi/extra-schemas",id:"api/openapi/extra-schemas",isDocsHomePage:!1,title:"Extra schemas usage",description:"ComponentSchema",source:"@site/docs/api/openapi/extra-schemas.md",sourceDirName:"api/openapi",slug:"/api/openapi/extra-schemas",permalink:"/docs/api/openapi/extra-schemas",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Extra schemas usage",sidebar_position:7},sidebar:"api",previous:{title:"Security protocols",permalink:"/docs/api/openapi/security"},next:{title:"Futher development",permalink:"/docs/api/futher"}},l=[{value:"ComponentSchema",id:"componentschema",children:[]}],u={toc:l};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"componentschema"},"ComponentSchema"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ComponentSchema")," is the only decorator that does not apply to route nodes, but to structures that\nare nested documents in data models, or for common data structure, if you need to show them into section\n",(0,a.kt)("inlineCode",{parentName:"p"},"Schemas")," of Swagger documentation."),(0,a.kt)("p",null,"It is recommended to use it for all models and data schemas: ",(0,a.kt)("inlineCode",{parentName:"p"},"aom")," will create links to the\nspecified types like ",(0,a.kt)("inlineCode",{parentName:"p"},'{$ref: "#/components/schema/ClassName"}')),(0,a.kt)("p",null,"The use of this decorator is due to the peculiarities of the work of the ",(0,a.kt)("inlineCode",{parentName:"p"},"class-validator")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"class-validator-jsonschema")," packages, which require observance of certain rules when using the\ndecorator ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/epiphone/class-validator-jsonschema#validatenested-and-arrays"},(0,a.kt)("inlineCode",{parentName:"a"},"@ValidateNested")),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// ...\n// ... data model with nested structure (using `typegoose`)\nclass Users {\n  @prop({ ref: () => Users })\n  @IsMongoId()\n  userId: Ref<Users>;\n\n  @prop({ type: () => HistoryAction })\n  @ValidateNested({ each: true })\n  @Type(() => HistoryAction)\n  history: HistoryAction[];\n}\n\n// ... subdocument `HistoryAction`\n// add a decorator to it, which will create a definition that the generator `json-schema` will refer to\n@ComponentSchema()\nclass HistoryAction extends JSONSchema {\n  @prop()\n  @IsString()\n  action: string;\n\n  @prop()\n  @IsDate()\n  actionDate: Date;\n}\n")),(0,a.kt)("p",null,"Thus, when generating documentation with using to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Users")," data model, the correct structure\nwill be obtained, taking data for the nested list."))}m.isMDXComponent=!0}}]);