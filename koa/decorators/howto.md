# Как это работает

Функциональность декораторов имеет следующую логику: все декораторы собирают мета-описание, которое
в последствии применится при вызове декоратора `@Router()`.

Такая конструкция нужна для того, чтоб иметь возможность выполнить конструкцию `@MixWith(source)`,
который обеспечит перенос миддлварей и бриджей, если они подразумеваются при наследовании классов.

Таким образом, каждый из декораторов вызывает процедуру `saveStorageData`, в которую передается
мета-ключ, конструктор, свойство и значение, которое будет сохранено в контексте этих данных.

Важно понимать, что некоторые данные являются константами, а некоторые - списками, и надо понимать,
как их разграничить между собой.

При вызове декоратора `@Router()` все данные извлекаются из хранилища и присваиваются в собственные
мета-данные, на которые потом распространяется уже имеющаяся логика.

