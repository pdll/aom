# Как это работает

Функциональность декораторов имеет следующую логику: все декораторы собирают мета-описание, которое
в последствии применится при вызове декоратора `@Router()`.

Такая конструкция нужна для того, чтоб иметь возможность выполнить конструкцию `@MixWith(source)`,
который обеспечит перенос миддлварей и бриджей, если они подразумеваются при наследовании классов.

Таким образом, каждый из декораторов вызывает процедуру `saveStorageData`, в которую передается
мета-ключ, конструктор, свойство и значение, которое будет сохранено в контексте этих данных.

Важно понимать, что некоторые данные являются константами, а некоторые - списками, и надо понимать,
как их разграничить между собой.

При вызове декоратора `@Router()` все данные извлекаются из хранилища и присваиваются в собственные
мета-данные, на которые потом распространяется уже имеющаяся логика.

### Проблемы

При передачи аргументов в виде массива возникает ситуация, что оно не является основанием для
ключа хранилища. При этом я определенно точно не могу передавать или `constuctor`, 
или `constructor[property]` в качестве аргументов, так как в этом случае не смогу по типу
понять, кто есть кто.
Чисто технически можно использовать мета-данные для того, чтобы маркировать гибридные состояния,
и тогда в момент обработки опираться на эту мету, и принимать решения, откуда и что извлекать.

Либо в общем случае для всех делать сохранение реверсивной меты, и извлекать все по одному
и тому же принципу для всех случаев. То есть считаем, что я передаю всегда некую функцию,
а будет это обращением к статичному методу или к конструктору - не так принципиально, потому что
я потом извлекаю из меты и то, и другое.


## Наследование миддлварей и бриджей

Все еще не решается проблема наследования миддлварей и бриджей.
Это можно списать на то, что она не решается в целом, либо поискать способ перехвата дескриптора
и дальнейшей его замены