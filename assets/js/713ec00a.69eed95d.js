"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[863],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return g}});var s=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,s,i=function(e,n){if(null==e)return{};var t,s,i={},r=Object.keys(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=s.createContext({}),u=function(e){var n=s.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=u(e.components);return s.createElement(o.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},c=s.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=u(t),g=i,f=c["".concat(o,".").concat(g)]||c[g]||p[g]||r;return t?s.createElement(f,a(a({ref:n},d),{},{components:t})):s.createElement(f,a({ref:n},d))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,a=new Array(r);a[0]=c;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var u=2;u<r;u++)a[u]=t[u];return s.createElement.apply(null,a)}return s.createElement.apply(null,t)}c.displayName="MDXCreateElement"},5792:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return u},toc:function(){return d},default:function(){return c}});var s=t(7462),i=t(3366),r=(t(7294),t(3905)),a=["components"],l={title:"Tags usage",sidebar_position:5},o=void 0,u={unversionedId:"api/openapi/tags",id:"api/openapi/tags",isDocsHomePage:!1,title:"Tags usage",description:"AddTag",source:"@site/docs/api/openapi/tags.md",sourceDirName:"api/openapi",slug:"/api/openapi/tags",permalink:"/docs/api/openapi/tags",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Tags usage",sidebar_position:5},sidebar:"api",previous:{title:"Request body structure",permalink:"/docs/api/openapi/request-body"},next:{title:"Security protocols",permalink:"/docs/api/openapi/security"}},d=[{value:"AddTag",id:"addtag",children:[]},{value:"UseTag",id:"usetag",children:[]},{value:"Tagging priority: IgnoreNextTags, ReplaceNextTags, MergeNextTags",id:"tagging-priority-ignorenexttags-replacenexttags-mergenexttags",children:[]}],p={toc:d};function c(e){var n=e.components,t=(0,i.Z)(e,a);return(0,r.kt)("wrapper",(0,s.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"addtag"},"AddTag"),(0,r.kt)("p",null,"The aom documentation supports grouping data by tags. To create a tag, it is necessary for the\nclass - route node - to apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"@AddTag")," decorator, which takes the ",(0,r.kt)("inlineCode",{parentName:"p"},"TagObject")," data structure\nas an argument:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface TagObject {\n  name: string; // tag name\n  description?: string; // tag description\n  externalDocs?: ExternalDocumentationObject; // external document object (https://swagger.io/specification/#external-documentation-object)\n}\n")),(0,r.kt)("h2",{id:"usetag"},"UseTag"),(0,r.kt)("p",null,"In order to apply the created tag, you need to add it to the ",(0,r.kt)("inlineCode",{parentName:"p"},"middleware")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"endpoint")," function\nusing the ",(0,r.kt)("inlineCode",{parentName:"p"},"@UseTag")," decorator."),(0,r.kt)("p",null,"The tag applied to the middleware applies to all endpoints of the route, until it is replaced\nby another tag on the route, or merged with it, if special rules are set (details below)."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@AddTag({ name: "File processing", description: "Standart methods for files" })\n@Use(Files.Init)\nclass Files {\n  @Get()\n  @Summary("Files list")\n  static Index() {\n    return fs.readdirSync(__dirname);\n  }\n\n  @Post()\n  @Summary("File upload")\n  static Upload(@Files("file") file: File) {\n    const filename = path.join(__dirname, file.name);\n    fs.renameSync(file.path, filename);\n    return filename;\n  }\n\n  @Middleware()\n  @UseTag(Files) //\n  static Init(@Next() next) {\n    return next();\n  }\n}\n')),(0,r.kt)("p",null,"All methods in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Files")," route node will be tagged with the ",(0,r.kt)("inlineCode",{parentName:"p"},"File processing"),"."),(0,r.kt)("h2",{id:"tagging-priority-ignorenexttags-replacenexttags-mergenexttags"},"Tagging priority: IgnoreNextTags, ReplaceNextTags, MergeNextTags"),(0,r.kt)("p",null,"A tag set with ",(0,r.kt)("inlineCode",{parentName:"p"},"@UseTag")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"endpoint")," has the highest priority and cannot be overridden.\nAt the same time, tags applied to ",(0,r.kt)("inlineCode",{parentName:"p"},"middleware"),', although they apply to all "underlying "functions,\ncan be replaced, ignored or combined with tags that may appear "further down the list".'),(0,r.kt)("p",null,"Let's consider an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// ... root.ts\nimport { $aom } from "./server";\n\n@Bridge("/users", Users)\n@Bridge("/files", Files)\n@AddTag({ name: "Basic methods" })\nclass Root {\n  @Get("/docs.json")\n  @Summary("Documentation")\n  static Docs() {\n    return docs;\n  }\n\n  @Get("/routes")\n  @Summary("Routes list")\n  static Routes() {\n    return $aom.routes;\n  }\n}\n\n// ... users.ts\n@AddTag({ name: "Users list processing" })\n@Bridge("/user_:user_id", User)\n@Use(Users.Init)\nclass Users {\n  @Summary("Users list")\n  @Get()\n  static Index() {\n    return models.Users.find();\n  }\n\n  @Summary("Add new user")\n  @Post()\n  static Add(@Body() body) {\n    return models.Users.create({ ...body });\n  }\n\n  @UseTag(Users)\n  @Middleware()\n  static Init(@Next() next) {\n    return next();\n  }\n}\n\n// ... user.ts\n@AddTag({ name: "Single user processing" })\n@Use(User.Init)\nclass User {\n  user: models.Users;\n\n  @Summary("User info")\n  @Get()\n  static Index(@This() { user }: User) {\n    return user;\n  }\n\n  @Summary("Delete user")\n  @Delete()\n  static Delete(@This() { user }: User) {\n    const result = await user.delete();\n    return result;\n  }\n\n  @UseTag(User)\n  @Middleware()\n  static async Init(@This() _this: User, @Params("user_id") userId, @Next() next) {\n    _this.user = await models.Users.findById(userId);\n    return next();\n  }\n}\n\n// ... files.ts\n@AddTag("Files list processing")\n@Bridge("/file_:file_id", File)\n@Use(Files.Init)\nclass Files {\n  where = {}; // files search criterias\n\n  @Summary("Files list")\n  @Get()\n  static Index(@This() _this: Files) {\n    return models.Files.find(where);\n  }\n\n  @UseTag(Files)\n  @Middleware()\n  static Init(@Next() next) {\n    return next();\n  }\n}\n\n// ... file.ts\n@AddTag("Single file processing")\n@Use(File.Init)\nclass File {\n  file: models.Files;\n\n  @Summary("File info")\n  @Get()\n  static Index(@This() { file }: Files) {\n    return file;\n  }\n\n  @Summary("Delete file")\n  @Delete()\n  static Delete(@This() { file }: Files) {\n    return file.remove();\n  }\n\n  @UseTag(File)\n  @Middleware()\n  static Init(\n    @This() _this: File,\n    @Params("file_id") fileId,\n    @StateMap(Files) { where }: Files,\n    @Next() next\n  ) {\n    _this.file = await models.Files.find({ _id: fileId, ...where });\n    return next();\n  }\n}\n')),(0,r.kt)("p",null,"By default, for all tags will be applied rule ",(0,r.kt)("inlineCode",{parentName:"p"},"ReplaceNextTags"),'. It means that as you "deep" into\nthe chain of functions, each new tag encountered will replace the previous one.'),(0,r.kt)("p",null,"Thus, in the above example, the default rule will work for all tags, and each group of requests\nwill be correctly marked with a tag of its own class, which will be propagated to them through\nthe initiated middleware."),(0,r.kt)("p",null,"That is, the tagging of ",(0,r.kt)("inlineCode",{parentName:"p"},"endpoints")," will be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> Basic methods\n  -- GET /docs.json\n  -- GET /routes\n> Users list processing\n  - GET /users\n  - POST /users\n> Single user processing\n  - GET /users/user_{user_id}\n  - DELETE /users/user_{user_id}\n> Files list processing\n  - GET /files\n> Single file processing\n  - GET /files/file_{file_id}\n  - DELETE /files/file_{file_id}\n")),(0,r.kt)("p",null,"Let's consider a situation when it is necessary to extend the functionality of the ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),"\nroute node by adding the ability to work with files belonging to this user, in the same methods\nas for other files."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// ... user.ts\n@AddTag({ name: "Single user processing" })\n@Use(User.Init)\nclass User {\n  user: models.Users;\n\n  @Summary("User info")\n  @Get()\n  static Index(@This() { user }: User) {\n    return user;\n  }\n\n  @Summary("Delete user")\n  @Delete()\n  static Delete(@This() { user }: User) {\n    const result = await user.delete();\n    return result;\n  }\n\n  // create a bridge to the `Files` route node\n  @Bridge("/files", Files)\n  static files(@Next() next, @This() { user }: User, @StateMap() stateMap) {\n    // add an instance of the Files class to StateMap,\n    // which will have special search criteria set only for those files that belong to the context user\n    const userFiles = new Files();\n    files.where = { userId: user._id };\n    stateMap.set(Files, userFiles);\n    return next();\n  }\n\n  @UseTag(User)\n  @Middleware()\n  static async Init(@This() _this: User, @Params("user_id") userId, @Next() next) {\n    _this.user = await models.Users.findById(userId);\n    return next();\n  }\n}\n')),(0,r.kt)("p",null,'As a result of this modification a situation arises that after connecting the bridge to\nthe tag "Files list processing" ( ',(0,r.kt)("inlineCode",{parentName:"p"},"@UseTag(Files)"),') and the "Single file processing"\n(',(0,r.kt)("inlineCode",{parentName:"p"},"@UseTag(File)"),") will fall as the methods that are provided in the context of work with the user."),(0,r.kt)("p",null,"That is, the list of methods in tags will become as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> Basic methods\n  -- GET /docs.json\n  -- GET /routes\n> Users list processing\n  - GET /users\n  - POST /users\n> Single user processing\n  - GET /users/user_{user_id}\n  - DELETE /users/user_{user_id}\n> Files list processing\n  - GET /files\n  - GET /users/user_{user_id}/files\n> Single file processing\n  - GET /files/file_{file_id}\n  - DELETE /files/file_{file_id}\n  - GET /users/user_{user_id}/files/file_{file_id}\n  - DELETE /users/user_{user_id}/files/file_{file_id}\n")),(0,r.kt)("p",null,'Obviously, this tagging is not entirely correct, and it is expected that the methods\nof working with user files will be somehow tied to the context of the "Single user processing" tag.'),(0,r.kt)("p",null,"To modify the tag processing logic, there are three decorators applied to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"middleware"),"- or ",(0,r.kt)("inlineCode",{parentName:"p"},"bridge"),"-functions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@IgnoreNextTags()")," - all tags following this decorator are ignored. The last active tag is\nused for marking."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@MergeNextTags()")," - all tags following this decorator are merged with the last active tag.\nIn this case, the number of further tags can be more than 1, and all of them will be combined\nsequentially. For merging, the symbol stored in the ",(0,r.kt)("inlineCode",{parentName:"li"},"mergeSeparator")," property of an instance\nof the",(0,r.kt)("inlineCode",{parentName:"li"}," OpenApi")," class is used. The default is ",(0,r.kt)("inlineCode",{parentName:"li"},"+"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@ReplaceNextTags()"),' - the subsequent tag as well as all further ones replace the last\nactive tag ("default" mode )')),(0,r.kt)("p",null,"Apply the decorator ",(0,r.kt)("inlineCode",{parentName:"p"},"@IgnoreNextTags()")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"bridge"),"-function into ",(0,r.kt)("inlineCode",{parentName:"p"},"User.files"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'class File {\n  // ....\n  // create a bridge to the `Files` route node\n  @Bridge("/files", Files)\n  @IgnoreNextTags()\n  static files(@Next() next, @This() { user }: User, @StateMap() stateMap) {\n    // add an instance of the Files class to StateMap,\n    // which will have special search criteria set only for those files that belong to the context user\n    const userFiles = new Files();\n    files.where = { userId: user._id };\n    stateMap.set(Files, userFiles);\n    return next();\n  }\n  // ...\n}\n')),(0,r.kt)("p",null,"Then the structure of the routes belonging to tags will be as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> Basic methods\n  -- GET /docs.json\n  -- GET /routes\n> Users list processing\n  - GET /users\n  - POST /users\n> Single user processing\n  - GET /users/user_{user_id}\n  - DELETE /users/user_{user_id}\n  - GET /users/user_{user_id}/files\n  - GET /users/user_{user_id}/files/file_{file_id}\n  - DELETE /users/user_{user_id}/files/file_{file_id}\n> Files list processing\n  - GET /files\n> Single file processing\n  - GET /files/file_{file_id}\n  - DELETE /files/file_{file_id}\n")),(0,r.kt)("p",null,"If we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"@MergeNextTags()")," decorator, we get the following structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> Basic methods\n  -- GET /docs.json\n  -- GET /routes\n> Users list processing\n  - GET /users\n  - POST /users\n> Single user processing\n  - GET /users/user_{user_id}\n  - DELETE /users/user_{user_id}\n> Single user processing+Files list processing\n  - GET /users/user_{user_id}/files\n> Single user processing+Files list processing+Single file processing\n  - GET /users/user_{user_id}/files/file_{file_id}\n  - DELETE /users/user_{user_id}/files/file_{file_id}\n> Files list processing\n  - GET /files\n> Single file processing\n  - GET /files/file_{file_id}\n  - DELETE /files/file_{file_id}\n")),(0,r.kt)("p",null,"Depending on preference and applied methodologies, you can choose one or another tagging strategy."),(0,r.kt)("p",null,"The decorators ",(0,r.kt)("inlineCode",{parentName:"p"},"@IgnoreNextTags()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@MergeNextTags()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@IgnoreNextTags()")," work on the principle\nof switches: that is, each subsequent one replaces the action of the previous one, and new rules\ntake effect after it. Thus, you can combine combinations of merging, replacements, or the use of\nthe last active tag."))}c.isMDXComponent=!0}}]);