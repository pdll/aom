"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3566],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),p=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=p(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,f=d["".concat(c,".").concat(m)]||d[m]||u[m]||o;return n?r.createElement(f,i(i({ref:t},l),{},{components:n})):r.createElement(f,i({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2169:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return l},default:function(){return d}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"Extra schemas usage",sidebar_position:7},c=void 0,p={unversionedId:"api/openapi/extra-schemas",id:"api/openapi/extra-schemas",isDocsHomePage:!1,title:"Extra schemas usage",description:"IsDefinition",source:"@site/docs/api/openapi/extra-schemas.md",sourceDirName:"api/openapi",slug:"/api/openapi/extra-schemas",permalink:"/docs/api/openapi/extra-schemas",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Extra schemas usage",sidebar_position:7},sidebar:"api",previous:{title:"Security protocols",permalink:"/docs/api/openapi/security"},next:{title:"Futher development",permalink:"/docs/api/futher"}},l=[{value:"IsDefinition",id:"isdefinition",children:[]}],u={toc:l};function d(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"isdefinition"},"IsDefinition"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"IsDefinition")," is the only decorator that does not apply to route nodes, but to structures that\nare nested documents in data models."),(0,o.kt)("p",null,"The use of this decorator is due to the peculiarities of the work of the ",(0,o.kt)("inlineCode",{parentName:"p"},"class-validator")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"class-validator-jsonschema")," packages, which require observance of certain rules when using the\ndecorator ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/epiphone/class-validator-jsonschema#validatenested-and-arrays"},(0,o.kt)("inlineCode",{parentName:"a"},"@ValidateNested")),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Important"),": Classes to which this decorator is applied must use the ",(0,o.kt)("inlineCode",{parentName:"p"},"static toJSON")," method to return\na valid JSON-schema value, similar to the examples above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ... jsonschema.ts\n// ... define a class that uses the storage from `class-transformer` for correct typecasting\nimport { targetConstructorToSchema } from "class-validator-jsonschema";\nimport { SchemaObject } from "openapi3-ts";\nimport { defaultMetadataStorage } from "class-transformer/cjs/storage";\n\nexport class JSONSchema {\n  static toJSON(): SchemaObject {\n    return targetConstructorToSchema(this, {\n      classTransformerMetadataStorage: defaultMetadataStorage,\n    });\n  }\n}\n// ...\n// ... data model with nested structure (using `typegoose`)\nclass Users extends BaseModel {\n  @prop({ ref: () => Users })\n  @IsMongoId()\n  userId: Ref<Users>;\n\n  @prop({ type: () => HistoryAction })\n  @ValidateNested({ each: true })\n  @Type(() => HistoryAction)\n  history: HistoryAction[];\n}\n\n// ... subdocument `HistoryAction`\n// add a decorator to it, which will create a definition that the generator `json-schema` will refer to\n@IsDefinition()\nclass HistoryAction extends JSONSchema {\n  @prop()\n  @IsString()\n  action: string;\n\n  @prop()\n  @IsDate()\n  actionDate: Date;\n}\n')),(0,o.kt)("p",null,"Thus, when generating documentation with using to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Users")," data model, the correct structure\nwill be obtained, taking data for the nested list."))}d.isMDXComponent=!0}}]);